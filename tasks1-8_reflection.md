# Рефлексия

### Задание 1

В эталонном решении явно задается порядок столбцов, которые будут в выдаче. Два плюса: более оптимально с точки зрения производительности и более удобный формат выдачи. Также в эталоне используются псевдонимы и алиасы. Это улучшает чтение SQL кода и улучшает чтение выдачи. Буду стремиться использовать такие подходы в будущем.

### Задание 2

В целом мое решение корректно, но можно улучшить 1 аспект: использовать явное перечисление колонок для выдачи. 

### Задание 3

В моем решение получение максимального приоритета вынесено в `SELECT`. Как выяснил, это может помешать получить максимальный приоритет именно для статусе `pending` и лучше следовало использовать подзапрос, как в эталонном решении. Про подзапросы подзабыл при решении задачи, буду иметь их теперь ввиду в дальнейшем.

### Задание 4

В эталонное решение выглядит лаконичным и более читаемым, сразу в COUNT указано поле для подсчета, я в этой части ошибся.

### Задание 5

В целом запросы получаются почти идентичными, только используется в эталоне группировка по уникальному идентификатору, что может быть более надежным. В остальном, не считая упомянутого форматирования и использования алиасов, получаются идентичные решения. 

### Задание 6

В эталонном случае `COUNT(T.task_id)` явно указывает столбец для подсчета, что может повысить читаемость и точность запроса.
В остальном решения идентичны, за исключением форматирования (которое буду улучшать) и использования алиасов

### Задание 7

Оператор HAVING в моем решении без конкретного условия, не имеет смысла, так как результаты уже группируются по items.type. 
И использовал более подход с блоком `WHERE` вместо `JOIN`

### Задание 8

В эталонном решении используется `NOT IN`, чтобы определить, что у гнома нет предметов. Мое решение использует `LEFT JOIN` и проверку на `NULL`, поэтому эталон выглядит более читабельнее и нагляднее. В остальном запрос делает то же самое.

В целом, в эталонных решениях помимо функциональных отличий используется форматирование, которое я пока не выработал ввиду редкого использования SQL. Буду улучшать этот аспект, с запросами я теперь работаю чаще. И используются алиасы и псевдонимы для построения более наглядных запросов.
